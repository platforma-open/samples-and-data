wf := import("@platforma-sdk/workflow-tengo:workflow")

maps := import("@platforma-sdk/workflow-tengo:maps")
ll := import("@platforma-sdk/workflow-tengo:ll")
smart := import("@platforma-sdk/workflow-tengo:smart")
file := import("@platforma-sdk/workflow-tengo:file")

json := import("json")

_P_COLUMN_DATA_RESOURCE_MAP := { Name: "PColumnData/ResourceMap", Version: "1" }
_P_COLUMN_DATA_JSON := { Name: "PColumnData/Json", Version: "1" }

// TODO implement
normalizeString := func(str) {
	return str
}

mapToPValueData := func(map) {
	data := {}
	for key, value in map {
		data[json.encode([key])] = value
	}
	result := {
		keyLength: 1,
		data: data
	}
	return result
}

createJsonPColumnData := func(data) {
	return smart.createValueResource(_P_COLUMN_DATA_JSON, data)
}

wf.body(func(args) {

	blockId := wf.blockId().getDataAsJson()

	sampleIdAxisSpec := {
		type: "String",
		name: "pl7.app/sampleId",
		annotations: {
			"pl7.app/label": "Sample"
		},
		domain: {
			"pl7.app/blockId": blockId
		}
	}

	exports := {}

	//
	// Creating metadata columns
	//

	for _, column in args.metadata {
		exports["metadata." + column.id] = {
			spec: {
				kind: "PColumn",
				name: "pl7.app/metadata",
				valueType: column.valueType,
				annotations: {
					"pl7.app/label": column.label
				},
				domain: {
					"pl7.app/columnId": column.global ? normalizeString(column.label) : column.id
				},
				axesSpec: [sampleIdAxisSpec]
			},
			data: createJsonPColumnData(json.encode(mapToPValueData(column.data)))
		}
	}

	//
	// Creating sample label column
	//

	exports["metadata.sampleId"] = {
		spec: {
			kind: "PColumn",
			name: "pl7.app/label",
			valueType: "String",
			annotations: {
				"pl7.app/label": args.sampleLabelColumnLabel,
				"pl7.app/isLabel": "true"
			},
			axesSpec: [sampleIdAxisSpec]
		},
		data: createJsonPColumnData(json.encode(mapToPValueData(args.sampleLabels)))
	}

	//
	// Creating datasets
	//

	fileImports := {}

	importFile := func(importHandle) {
		fromMap := fileImports[importHandle]
		if fromMap == undefined {
			fImport := file.importFile(importHandle)
			fileImports[importHandle] = fImport
			return fImport.file
		} else {
			return fromMap.file
		}
	}

	for _, dataset in args.datasets {
		exportKey := "dataset." + dataset.id

		if dataset.content.type == "Fasta" {
			fastaDataSpec := {
				kind: "PColumn",
				name: "pl7.app/sequencing/data",
				domain: {
					"pl7.app/fileExtension": dataset.content.gzipped ? "fasta.gz" : "fasta",
					"pl7.app/blockId": blockId
				},
				valueType: "File",
				annotations: {
					"pl7.app/label": dataset.label
				},
				axesSpec: [sampleIdAxisSpec]
			}

			data := smart.structBuilder(_P_COLUMN_DATA_RESOURCE_MAP, json.encode({
				keyLength: 1
			}))

			for sampleId, importHandle in dataset.content.data {
				if !importHandle {
					ll.panic("File handle not set for sample %v", sampleId)
				}
				data.createInputField(json.encode([sampleId])).set(importFile(importHandle))
			}

			exports[exportKey] = {
				spec: fastaDataSpec,
				data: data.lockAndBuild()
			}

			break
		}

		// Code below service Fastq and MultilaneFastq datasets

		readIndexAxisSpec := {
			type: "String",
			name: "pl7.app/sequencing/readIndex",
			annotations: {
				"pl7.app/label": "Read Index"
			},
			domain: {
				// Actually this is a special case of a more generic notion of
				// a "dense" axis with specified key value list.
				// When this concept will be fully defined, the domain most
				// probably should be renamed to "pl7.app/dense"
				"pl7.app/readIndices": string(json.encode(dataset.content.readIndices))
			}
		}

		fastqDataSpec := {
			kind: "PColumn",
			name: "pl7.app/sequencing/data",
			domain: {
				"pl7.app/fileExtension": dataset.content.gzipped ? "fastq.gz" : "fastq",
				"pl7.app/blockId": blockId
			},
			valueType: "File",
			annotations: {
				"pl7.app/label": dataset.label
			}
		}

		if dataset.content.type == "Fastq" {
			fastqDataSpec.axesSpec = [sampleIdAxisSpec, readIndexAxisSpec]

			data := smart.structBuilder(_P_COLUMN_DATA_RESOURCE_MAP, json.encode({
				keyLength: 2
			}))

			for sampleId, fileGroup in dataset.content.data {
				for _, readIndex in dataset.content.readIndices {
					importHandle := fileGroup[readIndex]
					if !importHandle {
						ll.panic("File handle not set for %v in sample %v", readIndex, sampleId)
					}
					data.createInputField(json.encode([sampleId, readIndex])).set(importFile(importHandle))
				}
			}

			exports[exportKey] = {
				spec: fastqDataSpec,
				data: data.lockAndBuild()
			}
		} else if dataset.content.type == "MultilaneFastq" {
			laneAxisSpec := {
				type: "String",
				name: "pl7.app/sequencing/lane",
				annotations: {
					"pl7.app/label": "Lane"
				}
			}
			fastqDataSpec.axesSpec = [sampleIdAxisSpec, laneAxisSpec, readIndexAxisSpec]

			data := smart.structBuilder(_P_COLUMN_DATA_RESOURCE_MAP, json.encode({
				keyLength: 3
			}))

			for sampleId, laneData in dataset.content.data {
				for laneId, fileGroup in laneData {
					for _, readIndex in dataset.content.readIndices {
						importHandle := fileGroup[readIndex]
						if !importHandle {
							ll.panic("File handle not set for %v, lane %v in sample %v", readIndex, laneId, sampleId)
						}
						data.createInputField(json.encode([sampleId, laneId, readIndex])).set(importFile(importHandle))
					}
				}
			}

			exports[exportKey] = {
				spec: fastqDataSpec,
				data: data.lockAndBuild()
			}
		} else {
			ll.panic("Unknow dataset type %v", dataset.content.type)
		}
	}

	return {
		outputs: {
			fileImports: smart.createMapResource(maps.mapValues(fileImports, func(im) {
				return im.handle
			}))
		},
		exports: exports
	}
})
