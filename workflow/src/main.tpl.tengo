wf := import("@milaboratory/tengo-sdk:workflow")

maps := import("@milaboratory/tengo-sdk:maps")
ll := import("@milaboratory/tengo-sdk:ll")
smart := import("@milaboratory/tengo-sdk:smart")
file := import("@milaboratory/tengo-sdk:file")

json := import("json")

_P_COLUMN_DATA_RESOURCE_MAP := { Name: "PColumnData/ResourceMap", Version: "1" }
_P_COLUMN_DATA_JSON := { Name: "PColumnData/Json", Version: "1" }

// TODO implement
normalizeString := func(str) {
	return str
}

mapToPValueData := func(map) {
	result := {}
	for key, value in map {
		result["[" + key + "]"] = value
	}
	return result
}

createJsonPColumnData := func(data) {
	return smart.createValueResource(_P_COLUMN_DATA_JSON, data)
}

wf.body(func(args) {

	blockId := wf.blockId().getDataAsJson()

	sampleIdAxisSpec := {
		type: "String",
		name: "pl7.app/sampleId",
		annotations: {
			"pl7.app/label": "Sample"
		},
		domain: {
			"pl7.app/blockId": blockId
		}
	}

	exports := {}

	//
	// Creating metadata columns
	//

	for _, column in args.metadata {
		exports["metadata." + column.id] = {
			spec: {
				kind: "PColumn",
				name: "pl7.app/metadata",
				valueType: column.valueType,
				annotations: {
					"pl7.app/label": column.label
				},
				domain: {
					"pl7.app/columnId": column.global ? normalizeString(column.label) : column.id
				},
				axesSpec: [sampleIdAxisSpec]
			},
			data: createJsonPColumnData(json.encode(mapToPValueData(column.data)))
		}
	}

	//
	// Creating sample label column
	//

	exports["metadata.sampleId"] = {
		spec: {
			kind: "PColumn",
			name: "pl7.app/label",
			valueType: "String",
			annotations: {
				"pl7.app/label": args.sampleLabelColumnLabel,
				"pl7.app/isLabel": "true"
			},
			axesSpec: [sampleIdAxisSpec]
		},
		data: createJsonPColumnData(json.encode(mapToPValueData(args.sampleLabels)))
	}

	//
	// Creating datasets
	//

	fileImports := {}

	importFile := func(importHandle) {
		fromMap := fileImports[importHandle]
		if fromMap == undefined {
			fImport := file.importFile(importHandle)
			fileImports[importHandle] = fImport
			return fImport.file
		} else {
			return fromMap.file
		}
	}

	for _, dataset in args.datasets {
		exportKey := "dataset." + dataset.id

		readIndexAxisSpec := {
			type: "String",
			name: "pl7.app/sequencing/readIndex",
			annotations: {
				"pl7.app/label": "Read Index"
			},
			domain: {
				// Actually this is a special case of a more generic notion of
				// a "dense" axis with specified key value list.
				// When this concept will be fully defined, the domain most
				// probably should be renamed to "pl7.app/dense"
				"pl7.app/readIndices": json.encode(dataset.content.readIndices)
			}
		}

		fastqDataSpec := {
			kind: "PColumn",
			name: "pl7.app/sequencing/data",
			domain: {
				"pl7.app/fileExtension": dataset.content.gzipped ? "fastq.gz" : "fastq",
				"pl7.app/blockId": blockId
			},
			valueType: "File",
			annotations: {
				"pl7.app/label": dataset.label
			}
		}

		if dataset.content.type == "Fastq" {
			fastqDataSpec.axesSpec = [sampleIdAxisSpec, readIndexAxisSpec]

			data := smart.structBuilder(_P_COLUMN_DATA_RESOURCE_MAP, json.encode({
				keyLength: 2
			}))

			for sampleId, fileGroup in dataset.content.data {
				for _, readIndex in dataset.content.readIndices {
					importHandle := fileGroup[readIndex]
					if !importHandle {
						ll.panic("File handle not set for %v in sample %v", readIndex, sampleId)
					}
					data.createInputField(json.encode([sampleId, readIndex])).set(importFile(importHandle))
				}
			}

			exports[exportKey] = {
				spec: fastqDataSpec,
				data: data.lockAndBuild()
			}
		} else if dataset.content.type == "MultilaneFastq" {
			laneAxisSpec := {
				type: "String",
				name: "pl7.app/sequencing/lane",
				annotations: {
					"pl7.app/label": "Lane"
				}
			}
			fastqDataSpec.axesSpec = [sampleIdAxisSpec, laneAxisSpec, readIndexAxisSpec]

			data := smart.structBuilder(_P_COLUMN_DATA_RESOURCE_MAP, json.encode({
				keyLength: 3
			}))

			for sampleId, laneData in dataset.content.data {
				for laneId, fileGroup in laneData {
					for _, readIndex in dataset.content.readIndices {
						importHandle := fileGroup[readIndex]
						if !importHandle {
							ll.panic("File handle not set for %v, lane %v in sample %v", readIndex, laneId, sampleId)
						}
						data.createInputField(json.encode([sampleId, laneId, readIndex])).set(importFile(importHandle))
					}
				}
			}

			exports[exportKey] = {
				spec: fastqDataSpec,
				data: data.lockAndBuild()
			}
		} else {
			ll.panic("Unknow dataset type %v", dataset.content.type)
		}
	}

	return {
		outputs: {
			fileImports: smart.createMapResource(maps.mapValues(fileImports, func(im) {
				return im.handle
			}))
		},
		exports: exports
	}
})
